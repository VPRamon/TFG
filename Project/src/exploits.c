#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "exploits.h"
#include "lists.h"
#include "utils.h"
#include "infgath.h"
#include "display.h"



void exploits_menu(struct sys_inf *system_info){
    
    system("clear");
    printf("[0] Default search\n"
           "[1] Manual Search\n"
           "[2] Load exploit");
    
    list *exploits = new_list();
    
    printf("\n>> Select an option [0-%d]: ", 2);
    char *input = read_stdin();
    int _input = valid_input(input[0], 3);
    free(input);
    
    switch(_input){
        case 0:
            if( (access( "/bin/searchsploit", F_OK ) == 0 ) || (access( "/sbin/searchsploit", F_OK ) == 0) || (access( "/usr/local/bin/searchsploit", F_OK ) == 0)) {
                char *r = parse_release(system_info->u_name->release);
                exploits = search_exploit(r);
                //display_exploits(exploits);
                goto opt;
            }
            else{                
                system("clear");
                printf("\nSearchsploit is not installed.\n"
                        "Please read the documentation or do a manual installation from https://www.exploit-db.com/searchsploit\n"
                        "\n\n<< press any key to go back");
                fgetc(stdin);
            }
            //free_exploits(exploits);
            break;
            
        case 1:
            system("clear");
            if( (access( "/bin/searchsploit", F_OK ) == 0 ) || (access( "/sbin/searchsploit", F_OK ) == 0) || (access( "/usr/local/bin/searchsploit", F_OK ) == 0)) {
                printf("Search exploit: ");
                char *in = read_stdin();
                exploits = search_exploit(in);
                goto opt;
                //free_exploits(exploits);
            }else{
                printf("\nSearchsploit is not installed.\n"
                        "Please read the documentation or do a manual installation from https://www.exploit-db.com/searchsploit\n"
                        "\n\n<< press any key to go back");
                fgetc(stdin);
            } 
                
            break;
        
        case 2:
            system("clear");
            printf("Give the path to the exploit: ");
            char path[100];
            fgets(path, 100 , stdin);
            char *dir = strtok(path, "\n");
            while(access( dir, F_OK ) != 0 ) {
                puts(dir);
                printf("Exploit not found! Make sure the path is correct and try again [q/quit]: ");
                fgets(path, 50 , stdin);
                dir = strtok(path, "\n");
                if(path[0] == 'q')
                    return;
            }
            
            exploits = new_list();
            load_exploit(exploits, path);
            goto opt;
            //free_exploits(exploits);
            break;
    }  
    opt:
        if(exploits->len == 0)
            return;
        display_exploits(exploits);
        printf("\n>> Pick exploit [0-%d]/[q]: ", exploits->len-1);
        
        char *index = read_stdin();

        if(index[0] == 'q')
            return;
        
        //CHECK IF VALID NUMBER !!
        element *el = get_element_from_list(exploits, atoi(index));
        struct exploit *xplt = (struct exploit *)el->content; 


        printf("\n\n[0] View exploit\n"
               "[1] Edit exploit\n"
               "[2] Change exploit\n"
               "[3] Run exploit\n"
               "[q] Quit\n");            

        printf("\n>> Select an option [0-%d]: ", 3);
        input = read_stdin();
        if(input[0] == 'q')
            return;
        _input = valid_input(input[0], 4);
        free(input);
        
        system("clear");
        switch(_input){
            case 0:
                display_exploit(xplt);
                printf("\n\n<< press any key to go back");
                fgetc(stdin);
                goto opt;
                break;

            case 1:
                edit_exploit(xplt);
                goto opt;
                break;

            case 2:
                goto opt;
                break;
            
            case 3:
                run_exploit(xplt);
                break;
        }
    
        printf("\n\n<< press any key to go back");
        fgetc(stdin);
}

void clean(char * input){
    int i = 0;
    int j = 0;
    int aux = 0;
    char c;
    while((c = input[i++]) != '\0' ){
        if(aux == 0 && c == 32)
            continue;
        
        if(c < 32)
            continue;
        
        if(c == 34)
            continue;
        
        input[j++] = c;
        aux = 1;
    }
    input[j++] = '\0';
}

struct exploit *get_new_exploit(char *string){
    struct exploit *exploit = (struct exploit *)malloc(sizeof(struct exploit));
    
    char *token = strtok_r(string, ",", &string);
    char *name = NULL; //strtok_r(token, ":", &token) ;
    
    while(token != NULL){
        name = strtok_r(token, ":", &token);
        
        if(!strcmp(name, "Title"))
            exploit->title = token;
        
        else if(!strcmp(name, "EDB-ID"))
            exploit->EDB_ID = token;
        
        else if(!strcmp(name, "Date"))
            exploit->date = token;
        
        else if(!strcmp(name, "Author"))
            exploit->author = token;
        
        else if(!strcmp(name, "Type"))
            exploit->type = token;
        
        else if(!strcmp(name, "Platform"))
            exploit->platform = token;
        
        else if(!strcmp(name, "Path"))
            exploit->path = token;
    
        token = strtok_r(string, ",", &string);
    }
    
    return exploit;
}

list *parse(char *json_string){
    if(json_string == NULL)
        return NULL;
    
    list *l = new_list();    
    char *item = NULL;
    char *name = NULL;
    //int a,z;
    
    while(strncmp(json_string, "RESULTS_EXPLOIT", 15))
        json_string++;
    
    json_string += 18;
    
    char* exploit = strtok_r(json_string, "}", &json_string);
    
    while( json_string[0] == ',' ){
        push(l, get_new_exploit(++exploit));
        json_string++;
        exploit = strtok_r(json_string, "}", &json_string);
    }
    
    if(json_string[0] == '\0')
        return NULL;
    
    push(l, get_new_exploit(++exploit));
    json_string++;
    exploit = strtok_r(json_string, "}", &json_string);
        
    return l;
}

list *search_exploit(char *query){
       
    size_t len = strlen(query);
    
    char *input = (char *)malloc(sizeof(char)*(30+len));
    strcpy(input, "searchsploit -j linux kernel ");
    strcat(input, query);
    
    char *out = system_cmd(input, 64);
    clean(out);
    list *exploits = parse(out); 
    
}

void free_exploits(list *exploits){
    
    element *p = exploits->last_element;
    while(p != NULL){
        /*struct exploit *xplt = p->content;
        if(xplt->title)
            free(xplt->title);
        if(xplt->EDB_ID)
            free(xplt->EDB_ID);
        if(xplt->date)
            free(xplt->date);
        if(xplt->author)
            free(xplt->author);
        if(xplt->type)
            free(xplt->type);
        if(xplt->platform)
            free(xplt->platform);
        if(xplt->path)
            free(xplt->path);
        */
        pop(exploits);
        p = exploits->last_element;
    }
    
}

void edit_exploit(struct exploit *xplt){
    
    //cpoy file to resources
    char cp[50]  = "cp ";
    strcat(cp, xplt->path);
    strcat(cp, " ../resources/exploits");
    system(cp);
    
    //get file name
    char filename[100];
    strcpy(filename, xplt->path);
    char* type = strtok(filename, ".");
    type = strtok(NULL, "\0");
    
    char filepath[100] = "vim ../resources/exploits/";
    strcat(filepath, xplt->EDB_ID);
    strcat(filepath, ".");
    strcat(filepath, type);
    
    //edit file with vim
    strcat(cp, xplt->path);
    system(filepath);
    system("clear");
    
}

void run_exploit(struct exploit *xplt){
    //puts(xplt->path);
    char path[100] = "gcc ";
    char out_name[50] = " -o ";
    strcat(path, xplt->path);
    printf("path: %s\n", path);
    strcat(out_name, xplt->EDB_ID);
    printf("title: %s\n", out_name);
    strcat(path, out_name);
    printf("command: %s\n", path);
    system(path);
}


void load_exploit(list *exploits, char *dir){
    
    struct exploit *exploit = (struct exploit *)malloc(sizeof(struct exploit));
    
    char *n = (char *)malloc(sizeof(char)*5);
    strcpy(n, "none");
    
    
    char *title = (char *)malloc(sizeof(char)*50);
    
    char* path = (char *)malloc(sizeof(char)*100);
    strcpy(path, dir);
            
    char* path_tmp = (char *)malloc(sizeof(char)*100);
    strcpy(path_tmp, dir);
    
    char *token = strtok_r(path_tmp, "/", &path_tmp);
    
    while(token != NULL){
        strcpy(title, token);
        token = strtok_r(path_tmp, "/", &path_tmp);
    }
    title = strtok(title, ".");
    
    exploit->title = title;

    exploit->EDB_ID = title;
        
    exploit->date = n;
    
    exploit->author = n;
    
    exploit->type = n;
    
    exploit->platform = n;
    
    exploit->path = path;
    
    push(exploits, exploit);
}
